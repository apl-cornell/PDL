# === comment
// === clock cycle boundary
=  === blocking write (a.k.a combinational logic, w/in a clock cycle)
<- === non-blocking write (a.k.a register or memory update, is visible next clock cycle)

#This block is the dest of definitions for instantiating the cpu
def cpu {
    #some pseudo syntax here for defining the units in our datapath
    imem = new cache<insn>();
    rf = new regfile();
    dmem = new cache<data>();
    alu = new arith_unit();
    bpred = new branch_pred();
}

#This implements a CISC ISA where instructions are of the form <op> <dest> <arg1> <arg2>
#Where args and dest can be register indices or memory locations
#This implementation makes it clear how memory requests are ordered when it can
#multiple memory arguments.

cpu(pc) {
  insn <- imem.send(pc);
  ---
  op = opcode(insn); #selects some bits from the instruction
  rs1 = rs1(insn);
  rs2 = rs2(insn);
  dest = dest(insn);
  call cpu(pc + 4);
  split {
    case: (rs1 == RF and rs2 == RF and
    rf[rs1].acquire() and rf[rs2].acquire()) {
      ---
      arg1 <- rf.read(rs1);
      arg2 <- rf.read(rs2);
    }
    case: (rs1 == MEM and rs2 == MEM
    and dmem.acquire()) {
      ---
      arg1 <- dmem.read(rs1);
      ---
      arg2 <- dmem.read(rs2);
    }
    case: (rs1 == RF and rs2 == MEM
    and rf[rs1].acquire() and dmem.acquire()) {
      ---
      arg1 <- rf.read(rs1);
      arg2 <- dmem.read(rs2);
    }
    case: (rs1 == MEM and rs2 == RF
    and rf[rs2].acquire() and dmem.acquire()) {
      ---
      arg1 <- dmem.read(rs1);
      arg2 <- rf.read(rs2);
    }
  } join {  //needs an ordering mechanism
    // in concurrent semantics, could implement this as each "branch"
    // has its own channel to the "join" point, which it tags with the
    // thread ID; then, the join receive statement has to "expect"
    // the next thread ID and only accept that one. This is straightforward
    // since the "branch" and "join" stages can just have their own counters
    // for thread IDs internally that they're incrementing as they send and recv
    // data respectively.

    // alternatively, there is a single channel which is shared between the
    // branches and the channel itself keeps track of ordering by the same
    // mechanism as described above, except using state internal to the
    // branching send and joining receive channels.
    ---
    res <- alu(arg1, arg2, op);
    ---
    if (dest == MEM) {
      dmem.acquire(); //need to lift this to earliest lock acquisition point
      dmem.write(dest, res);
    } else {
      rf[dest].acquire(); //ditto
      rf.write(dest, res);
    }
  }
}

#actually instantiate and inintialize the cpu
main {
  cpu = new cpu();
  cpu.send(0);
}

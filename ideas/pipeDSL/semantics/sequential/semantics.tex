\documentclass{article}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{ttquot}
\usepackage{pl-syntax}

\newcommand{\step}[0]{\ensuremath{\rightarrow}}
\newcommand{\bstep}[0]{\ensuremath{\Downarrow}}
\newcommand{\pstep}[0]{\ensuremath{\rightarrow_{\mathcal{S}}}}
\newcommand{\skips}[0]{~\textsf{skip}~}
\newcommand{\outputs}[0]{~\textsf{output}~}
\newcommand{\spawns}[0]{~\textsf{spawn}~}
\newcommand{\locks}[0]{~\textsf{wait-for-lock}~}
\newcommand{\bypass}[0]{~\textsf{bypass}~}
\newcommand{\bop}{~\textsf{bop}~}
\newcommand{\uop}{~\textsf{uop}~}
\newcommand{\tdash}{\ensuremath{---}}
\makeatletter
\newcommand{\conf}[1]{\langle #1\@confx}
\newcommand\@confx{\@ifnextchar\stopconf{\@confend}{\@confi}}
\newcommand\@confend[1]{\rangle}
\newcommand\@confi[1]{,#1 \@confx}
\makeatother

\begin{document}

\title{Sequential Semantics for Pipeline DSL}
\author{Drew Zagieboylo}
\maketitle

\section{MetaVariables}
\begin{align*}
  \begin{array}{lc}
    \mbox{Integers} & n \\
    \mbox{Variables} & v,f\\
    \mbox{Expressions} & e\\
    \mbox{Statements} & c\\
    \mbox{Functions} & \mathcal{F}\\
    \mbox{Objects} & \mathcal{O}\\
  \end{array}
\end{align*}

\section{Type System}

The type system is used to enforce a number of constraints
that will ensure compilation of the program to a concurrent
system maintains correctness. This involves typechecking
a few different sets of rules:

\begin{itemize}
\item Base Types - Normal types for circuits like sized integers and booleans.
  We have a very limited notion of base types, like a subset of FIRRTL. This is mostly
  uninteresting.
\item Operation Timing - We have both synchronous (combinational) and asynchronous
  assignment. The latter is used to access arrays and external modules and the results
  of such operations take time to become available. We ensure that all variable
  accesses occur once their data has been made available (via logical the time-step operation '---').
  This is also relatively uninteresting.
\item Lock Acquisition - A key mechanism for ensuring correctness is ensuring
  that stateful operations (like writing to memories) happen in order. We ensure
  this order by forcing memory-accessing operations to happen only after the associated
  lock has been acquired. A secondary requirement of this check is that locks are
  acquired in-order; we enforce this by ensuring that there is exactly one point
  in the pipeline at which locks are acquired. This requirement can be relaxed with
  non-blocking acquisition (which we call reservation) that can happen in-order without
  forcing early pipeline stalls waiting for a lock that won't be needed until later.
\item Speculation - Speculation introduces some complexity and we must also
  prevent speculative code from executing any irreversible operations (such as
  modifying memory). However, speculative code *can* acquire and free locks,
  in certain cases. This checker ensures that all of those happen appropriately.
\end{itemize}

\begin{figure}[h]
  \begin{syntax}
    \abstractCategory[Variables]{v, x, z}
    \abstractCategory[Command]{c}
    \abstractCategory[Memory]{m}
    \category[LockState]{s}
    \alternative{"free"}
    \alternative{"reserved"}
    \alternative{"acquired"}
    \alternative{"released"}
    \category[LockMap]{L}
    \alternative{ m \mapsto s }
  \end{syntax}
\end{figure}

\subsection{Lock Acquisition}

\begin{mathpar}
  L_{x} = \{l | L(l) = "x"\}\\
  L_1 " merge " L_2 = \{ m \mapsto s | s =
  \begin{cases}
    L_1(m) & L_1(m) = L_2(m)\\
    "released" & L_1(m) = "free" || L_2(m) = "free"\\
    UNDEFINED &
  \end{cases}\}\\
  \boxed{L \vdash c \dashv L'}\\
  \inferrule*[Left=MemRead]{ L(m) = "acquired"}
             { L \vdash m[idx] \leftarrow v \dashv L }\\
  \inferrule*[Left=MemWrite]{ L(m) = "acquired"}
             { L \vdash v \leftarrow m[idx] \dashv L }\\
  \inferrule*[Left=Acquire]{ L(m) \in \{"reserved","free"\}}
             {L \vdash "acquire"(m) \dashv L[m \mapsto "acquired"] }\\
  \inferrule*[Left=Free]{ L(m) = "acquired" }
             {L \vdash "free"(m) \dashv L[m \mapsto "released"] }\\
  \inferrule*[Left=Reserve]{ L(m) = "free"}
             {L \vdash "reserve"(m) \dashv L[m \mapsto "reserved"]}\\
  \inferrule*[Left=Seq]{ L \vdash c_1 \dashv L'' \\ L'' \vdash c_2 \dashv L'}
             {L \vdash c_1;c_2 \dashv L'}\\
  \inferrule*[Left=T-Seq]{ L \vdash c_1 \dashv L'' \\ L'' \vdash c_2 \dashv L'}
             {L \vdash c_1 \tdash c_2 \dashv L'}\\
  \inferrule*[Left=If]{i \in \{t,f\} \\ L \vdash c_i \dashv L^i \\
    L^{iac} = L_{free} - L^i_{free} \\
    "dom"(L^{tac}) \cap "dom"(L^{fac}) = \emptyset \\
    L^i_{acq|res} \subseteq L_{acq|res} \\
    L^t_{acq|res} = L^f_{acq|res} \\
    L' = L^t " merge " L^f }
             {L \vdash "if " e " then " c_t " else " c_v \dashv L'}\\
  \inferrule*[Left=Speculate]{ L \vdash v \leftarrow e \dashv L \\
    L \vdash c_v \dashv L^v \\ L \vdash c_s \dashv L^s \\ L^v \vdash c_s \dashv L^{s'} \\
    L^v_{released} = L^{s'}_{released}}
             {L \vdash "predict"(v \leftarrow e, c_v, c_s) \dashv L'}
\end{mathpar}

Locks must be "acquired" to access the associated memory. Once a lock
is "free"ed, it cannot be acquired again since it is in the "released" state.
Locks may be "reserved" before being acquired as well; this is basically non-blocking
acquire. A later "acquire" is necessary to block until the lock is available.

Locks cannot be acquired or reserved in multiple places; therefore both
branches of an if statement must acquire or reserve a disjoint set of locks.
The $L^{tac}$ and $L^{fac}$ lock maps represent any locks which have gone from
"free" before the if to released. Essentially each lock may be acquired in at most
one of the branches. After the if, both branches must agree on the set of still
acquired/reserved locks. Any locks only used in one branch are no longer available
for use after the if (i.e. they are in the "released" state).
_N.B. there is probably a better way to check this using some affine logic_

During speculation, both branches will execute (potentially in parallel). Therefore,
lock acquisitions made in one branch are not available to the other but already acquired/reserved
locks can be used in either branch. Essentially, the speculative code must be able
to typecheck with or without the lockstates changed by the non-speculative branch.
The final lock states are those set after executing both branches in serial.
As a further restriction, the speculative statement
cannot release any locks, since this would potentially invalidate
some of its memory access operations during re-execution.

\section{Operational Semantics}
Expression Semantics
\begin{mathpar}
  \inferrule*[Left={Int-Lookup}]{\sigma(v) = n}{\conf{\sigma}{v}\stopconf \bstep n}\\
  \inferrule*[Left={Uop}]{\conf{\sigma}{e}\stopconf \bstep n' \\ \uop n' = n''}
             {\conf{\sigma}{\uop n}\stopconf \bstep n''}\\
  \inferrule*[Left={Binop}]{\conf{\sigma}{e_1}\stopconf \bstep n \\ \conf{\sigma}{e_2}\stopconf \bstep n' \\ n \bop n' = n''}
             {\conf{\sigma}{e_1 \bop e_2}\stopconf \bstep n''}\\
  \inferrule*[Left={Function Call}]{f \in \mathcal{F} \\ \conf{\sigma}{e}\stopconf \bstep n' \\ f(n') = n}
             {\conf{\sigma}{f(e)}\stopconf \bstep n} \\
\end{mathpar}
Module Invocation
\begin{mathpar}
  \inferrule*[Left={Message Send}]{r = \{name, e_1...e_m\} \\ v \in \mathcal{O} \\ \textsf{invoke}(v, name, e_1...e_m) = n}
             {\conf{\sigma}{v.send(r)}\stopconf \bstep n}\\
\end{mathpar}
Statement Semantics
\begin{mathpar}
  \inferrule*[Left={Lock}]{ }
             {\conf{\sigma}{\Delta}{\locks v}\stopconf \step \conf{\sigma}{\Delta}{\skips}\stopconf}\\
  \inferrule*[Left={Output}]{\conf{\sigma}{e}\stopconf \bstep n}
             {\conf{\sigma}{\Delta}{\outputs e}\stopconf \step_{\{\outputs n\}} \conf{\sigma}{\Delta}{\skips}\stopconf}\\
  \inferrule*[Left={Asynch-Assign}]{ \conf{\sigma}{v_2.send(r)}\stopconf \bstep n \\ \Delta' = \Delta[v_1 \mapsto n]}
             {\conf{\sigma}{\Delta} {v_1 \leftarrow v_2.send(r)}\stopconf \step_r \conf{\sigma}{\Delta'}{\skips}\stopconf}\\
  \inferrule*[Left={Asynch-Bypass}]{ \conf{\sigma}{v_2.send(r)}\stopconf \bstep n \\ \Delta' = \Delta[v_1 \mapsto n]}
             {\conf{\sigma}{\Delta} {v_1 \leftarrow \bypass v_2.send(r)}\stopconf \step_r \conf{\sigma}{\Delta'}{\skips}\stopconf}\\
  \inferrule*[Left={Assign}]{ \conf{\sigma}{e}\stopconf \bstep n \\ \sigma' = \sigma[v \mapsto n]}
             {\conf{\sigma}{\Delta}{v = e}\stopconf \step \conf{\sigma'}{\Delta}{\skips}\stopconf}\\
  \inferrule*[Left={If-True}]{\conf{\sigma}{e}\stopconf \bstep n \\ n != 0 }
             {\conf{\sigma}{\Delta}{\textsf{if~}(e)\textsf{~then~} s_1 \textsf{~else~}s_2}\stopconf \step \conf{\sigma}{\Delta}{s_1}\stopconf}\\
  \inferrule*[Left={If-False}]{\conf{\sigma}{e}\stopconf \bstep 0}
             {\conf{\sigma}{\Delta}{\textsf{if~}(e)\textsf{~then~} s_1 \textsf{~else~}_2}\stopconf \step \conf{\sigma}{\Delta}{s_2}\stopconf}\\
  \inferrule*[Left={Seq}]{\conf{\sigma}{\Delta}{s_1}\stopconf \step \conf{\sigma'}{\Delta'}{s_1'}\stopconf}
             {\conf{\sigma}{\Delta}{s_1 ; s_2}\stopconf \step \conf{\sigma'}{\Delta'}{s_1';s_2}\stopconf}\\
  \inferrule*[Left={Seq-Term}]{ }{\conf{\sigma}{\Delta}{\skips ; s}\stopconf \step \conf{\sigma}{\Delta}{s}\stopconf}\\
  \inferrule*[Left={TimeBarrier}]{\conf{\sigma}{\Delta}{s_1}\stopconf \step \conf{\sigma'}{\Delta'}{s_1'}\stopconf}
             {\conf{\sigma}{\Delta}{s_1 --- s_2}\stopconf \step \conf{\sigma'}{\Delta'}{s_1' --- s_2}\stopconf}\\
  \inferrule*[Left={Spawn}]{\textsf{args} \not\in \sigma \\ r = \{e_1...e_m\} \\
    \conf{\sigma}{e_i}\stopconf \bstep n_i \\ \sigma' = \sigma[\textsf{args} = \{n_1...n_m\}]}
             {\conf{\sigma}{\Delta}{\spawns r}\stopconf \step \conf{\sigma'}{\Delta}{\skips}\stopconf}\\
\end{mathpar}
Pipeline Semantics
\begin{mathpar}
  \inferrule*[Left={Eval-Event}]{s != \skips \\
    \conf{\sigma}{\Delta}{s}\stopconf \step_t \conf{\sigma'}{\Delta'}{s'}\stopconf \\ t != \emptyset}
             {\conf{\sigma}{\Delta}{\mathcal{T}}{\tau}{s}\stopconf \pstep \conf{\sigma'}{\Delta'}{\mathcal{T}}{\tau \cup \{t\}}{s'}\stopconf}\\
  \inferrule*[Left={Eval}]{s != \skips \\ \conf{\sigma}{\Delta}{s}\stopconf \step \conf{\sigma'}{\Delta'}{s'}\stopconf}
             {\conf{\sigma}{\Delta}{\mathcal{T}}{\tau}{s}\stopconf \pstep \conf{\sigma'}{\Delta'}{\mathcal{T}}{\tau}{s'}\stopconf}\\
  \inferrule*[Left={TimeBar-Term}]{\Delta' = \emptyset \\ \{x_1...x_m\} = \textsf{dom}(\Delta) \\
    \sigma' = \sigma[x_1 \mapsto \Delta(x_1)]...[x_m \mapsto \Delta(x_m)] \\ \tau' = \emptyset}
             {\conf{\sigma}{\Delta}{\skips --- s}\stopconf \step \conf{\sigma'}{\Delta'}{\mathcal{T};\tau}{\tau'}{s}\stopconf}\\
  \inferrule*[Left={Loop}]{\{n_1...n_m\} = \sigma(\textsf{args}) \\ \sigma' = \{"one" \mapsto n_1..."m" \mapsto n_m\} \\
    \Delta' = \emptyset \\ \tau' = \emptyset}
             {\conf{\sigma}{\Delta}{\mathcal{T}}{\tau}{\skips}\stopconf \pstep
               \conf{\sigma'}{\Delta'}{\mathcal{T};\tau}{\tau'}{\mathcal{S}}\stopconf}\\
\end{mathpar}
\end{document}

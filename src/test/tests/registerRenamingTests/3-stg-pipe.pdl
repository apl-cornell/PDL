//need to specify lock implementation type somehow
//perhaps rf: int<32>[5]<c,s>RENAME
//        imem: int<32>[32]<a,a>FAQUEUE
//        rf2: int<32>[5]<c,s>QUEUE
//        dmem: int<32>[5]<a,a>LSQ
//memories come with: data type, addr type, read latency, lock impl
//lock impls are named, e.g., QUEUE, FAQUEUE, RENAME, LSQ
//lock impls are compatible w/ specific memory latencies

pipe test(input: int<32>)[rf: int<32>[5]<c,s>(RenameRF)]: bool {
    int<5> rs1 = input{0:4};
    int<5> rd = rs1 - 1<5>;
    if (input < 100<32>) {
        call test(input + 1<32>);
    } else {
        output(true);
    }
    start(rf);
    reserve(rf[rs1], R);
    reserve(rf[rd], W);
    end(rf);
    ---
    block(rf[rs1]);
    int<32> arg = 1<32> + rf[rs1];
    release(rf[rs1]);
    ---
    block(rf[rd]);
    rf[rd] <- arg;
    release(rf[rd]);
    ---
}

circuit {
    rf = regfile(int<32>, 5);
    t = new test[RenameRF(rf)];
    call t(0<32>);
}
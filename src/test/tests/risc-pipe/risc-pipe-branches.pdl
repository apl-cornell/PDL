def alu(arg1: int<32>, arg2: int<32>, op: int<3>, flip: int<1>): int<32> {
    int<5> shamt = arg2{4:0};
    if (op == 0<3>) {  //000 == ADD , flip == sub
       if (flip == 0<1>) {
         return arg1 + arg2;
       } else {
         return arg1 - arg2;
       }
    } else {
    if (op == 1<3>) { //001 == SLL
        return arg1 << shamt;
    } else {
    if (op == 2<3>) { //010 == SLT 
        return (arg1 < arg2) ? 1<32> : 0<32>; //todo signed vs unsigned
    } else {
    if (op == 3<3>) { //011 == SLTU
        return (arg1 < arg2) ? 1<32> : 0<32>;
    } else {
    if (op == 4<3>) { //100 == XOR
        return arg1 ^ arg2;
    } else {
    if (op == 5<3>) { //101 == SRL / SRA
      if (flip == 0<1>) {
        return arg1 >> shamt; //SRL
      } else {
        return arg1 >> shamt; //SRA todo support difference here
      }
    } else {
    if (op == 6<3>) { //110 == OR
        return arg1 ^ arg2;
    } else { //111 == AND
        return arg1 & arg2;
    }}}}}}}
    
}

def br(pc: int<16>, off:int<16>, op:int<3>, arg1:int<32>, arg2:int<32>): int<16> {
    int<16> offpc = pc + off;
    int<16> npc = pc + 1<16>;
    if (op == 0<3>) { //BEQ
        if (arg1 == arg2) { return offpc; } else { return npc; }
    } else {
    if (op == 1<3>) { //BNE
       if (arg1 != arg2)  { return offpc; } else { return npc; }
    } else {
    if (op == 4<3>) { //BLT
       if (arg1 < arg2)  { return offpc; } else { return npc; }
    } else {
    if (op == 5<3>) { //BGE
       if (arg1 >= arg2)  { return offpc; } else { return npc; }
    } else {
    if (op == 6<3>) { //BLTU
       if (arg1 < arg2)  { return offpc; } else { return npc; } //todo unsigned
    } else {
    if (op == 7<3>) { //BGEU
       if (arg1 >= arg2) { return offpc; } else { return npc; } //todo unsigned
    } else {
      return npc;
    }}}}}}
}


pipe cpu(pc: int<16>)[rf: int<32>[5]<c,s>, imem: int<32>[16]<a,a>, dmem: int<32>[16]<a,a>] {
    start(imem);
    acquire(imem[pc]);
    int<32> insn <- imem[pc];
    release(imem[pc]);
    end(imem);
    ---
    int<7> opcode = insn{6:0};
    int<5> rs1 = insn{19:15};
    int<5> rs2 = insn{24:20};
    int<5> rd = insn{11:7};
    int<7> funct7 = insn{31:25};
    int<3> funct3 = insn{14:12};
    int<1> flip = insn{30:30};
    int<32> immI = 0<20> ++ insn{31:20}; //todo support signextend
    int<32> immS = 0<20> ++ (insn{31:25} ++ insn{11:7}); //todo signextend
    int<16> immB = 0<5> ++ insn{7:7} ++ insn{30:25} ++ insn{11:8}; //todo real risc5
    int<16> immJ = insn{16:12} ++ insn{20:20} ++ insn{30:25} ++ insn{24:21}; //todo real risc5
    int<32> immU = insn{31:12} ++ 0<12>;
    bool isOpImm = opcode == 0b0010011<7>;
    bool isOp    = opcode == 0b0110011<7>;
    bool isJal   = opcode == 0b1101111<7>;
    bool isBranch = opcode == 0b1100011<7>;
    bool isStore = opcode == 0b0100011<7>;
    bool isLoad = opcode == 0b0000011<7>;
    bool needrs1 = !isJal;
    bool needrs2 = isOp || isBranch || isStore;
    bool writerd = opcode{6:5} == 0<2>;
    start(rf);
    if (needrs1) {
       acquire(rf[rs1]);
       int<32> rf1 = rf[rs1];
       release(rf[rs1]);
    } else {
      int<32> rf1 = 0<32>;
    }
    if (needrs2) {
       acquire(rf[rs2]);
       int<32> rf2 = rf[rs2];
       release(rf[rs2]);
    } else {
       int<32> rf2 = 0<32>;
    }
    if (writerd) {
       reserve(rf[rd]);
    }
    end(rf);
    ---
    if (isBranch) {
       int<16> npc = br(pc, immB, funct3, rf1, rf2);
    } else {
    if (isJal) {
       int<16> npc = pc + 1<16>; //todo
    } else {
       int<16> npc = pc + 1<16>;
    }}
    call cpu(npc);
    int<32> alu_arg2 = (isOpImm) ? immI : rf2;
    int<32> alu_res = alu(rf1, alu_arg2, funct3, flip);
    if (isStore) {
       int<32> tmp = (immS + rf1);
       int<16> memaddr = tmp{15:0};
    } else {
    if (isLoad) {
       int<32> tmp = (immI + rf1);
       int<16> memaddr = tmp{15:0};
    } else {
      int<16> memaddr = 0<16>;
    }}
    ---
    if (isStore || isLoad) {
       start(dmem);
       acquire(dmem[memaddr]);
       end(dmem);
       if (isStore) {
    	 dmem[memaddr] <- rf2;
    	 int<32> wdata <- 0<32>;
       } else {
       	 int<32> wdata <- dmem[memaddr];
       }
       release(dmem[memaddr]);
    } else {
      int<32> wdata <- alu_res;
    }
    ---
    if (writerd) {
       block(rf[rd]);
       	  rf[rd] <- wdata;
       release(rf[rd]);
    }    
}

circuit {
    i = memory(int<32>, 16);
    d = memory(int<32>, 16);
    r = regfile(int<32>, 5);
    c = new cpu[r, i, d];
    call c(0<16>);
}
def mul(arg1: int<32>, arg2: int<32>, op: uint<3>): int<32> {
    uint<32> mag1 = cast(mag(arg1), uint<32>);
    uint<32> mag2 = cast(mag(arg2), uint<32>);
    //MULHU => positive sign always
    int<32> s1 = (op == u3<3>) ? 1<32> : sign(arg1);
    //MULHU/MULHSU => positive sign always
    int<32> s2 = (op >= u2<3>) ? 1<32> : sign(arg2);    
    int<64> magRes = cast((mag1 * mag2), int<64>);
    int<64> sm = s1 * s2;
    //multiply but preserve bit width
    int<64> m = magRes $* sm;
    if (op == u0<3>) { //MUL
      	return m{31:0};
    } else {
     	return m{63:32};
    }
}

def alu(arg1: int<32>, arg2: int<32>, op: uint<3>, flip: bool): int<32> {
    uint<5> shamt = cast(arg2{4:0}, uint<5>);
    if (op == u0<3>) {  //000 == ADD , flip == sub
       if (!flip) {
         return arg1 + arg2;
       } else {
         return arg1 - arg2;
       }
    } else {
    if (op == u1<3>) { //001 == SLL
        return arg1 << shamt;
    } else {
    if (op == u2<3>) { //010 == SLT 
        return (arg1 < arg2) ? 1<32> : 0<32>;
    } else {
    if (op == u3<3>) { //011 == SLTU
       uint<32> un1 = cast(arg1, uint<32>);
       uint<32> un2 = cast(arg2, uint<32>);
       return (un1 < un2) ? 1<32> : 0<32>;
    } else {
    if (op == u4<3>) { //100 == XOR
        return arg1 ^ arg2;
    } else {
    if (op == u5<3>) { //101 == SRL / SRA
      if (!flip) {
        return cast((cast(arg1, uint<32>)) >> shamt, int<32>); //SRL
      } else {
        return arg1 >> shamt; //SRA
      }
    } else {
    if (op == u6<3>) { //110 == OR
        return arg1 | arg2;
    } else { //111 == AND
        return arg1 & arg2;
    }}}}}}}
    
}

def br(pc: int<16>, off:int<16>, op:uint<3>, arg1:int<32>, arg2:int<32>): int<16> {
    //divide by 4 b/c we count instructions not bytes
    int<16> offpc = pc + (off >> 2);
    int<16> npc = pc + 1<16>;
    if (op == u0<3>) { //BEQ
        if (arg1 == arg2) { return offpc; } else { return npc; }
    } else {
    if (op == u1<3>) { //BNE
       if (arg1 != arg2)  { return offpc; } else { return npc; }
    } else {
    if (op == u4<3>) { //BLT
       if (arg1 < arg2)  { return offpc; } else { return npc; }
    } else {
    if (op == u5<3>) { //BGE
       if (arg1 >= arg2)  { return offpc; } else { return npc; }
    } else {
    if (op == u6<3>) { //BLTU
        uint<32> un1 = cast(arg1, uint<32>);
        uint<32> un2 = cast(arg2, uint<32>);
        if (un1 < un2)  { return offpc; } else { return npc; }
    } else {
    if (op == u7<3>) { //BGEU
        uint<32> un1 = cast(arg1, uint<32>);
        uint<32> un2 = cast(arg2, uint<32>);
        if (un1 >= un2) { return offpc; } else { return npc; }
    } else {
      return npc;
    }}}}}}
}

pipe multi_mul(a1: int<32>, a2: int<32>, op: uint<3>)[]: int<32> {
     uint<32> ua1 = cast(a1, uint<32>);
     uint<32> ua2 = cast(a2, uint<32>);
     int<32> rr = a1{15:0} * a2{15:0};
     int<32> rl = a1{15:0} * a2{31:16};
     int<32> lr = a1{31:16} * a2{15:0};
     int<32> ll = a1{31:16} * a2{31:16};
     ---
     int<32> t1 = rl + lr;
     int<32> res = (t1 << 16<5>) + rr;
     output(res);
}

pipe cpu(pc: int<16>)[rf: int<32>[5]<c,s>(FAQueue), imem: int<32>[16]<a,a>(Queue), dmem: int<32>[16]<a,a>(FAQueue)]: bool {
    start(imem);
    acquire(imem);
    int<32> insn <- imem[cast(pc, uint<16>)];
    release(imem);
    end(imem);
    ---
    //This OPCODE is J Self and thus we're using it to signal termination
    bool done = insn == 0x0000006f<32>;
    int<7> opcode = insn{6:0};
    uint<5> rs1 = cast(insn{19:15}, uint<5>);
    uint<5> rs2 = cast(insn{24:20}, uint<5>);
    uint<5> rd = cast(insn{11:7}, uint<5>);
    uint<7> funct7 = cast(insn{31:25}, uint<7>);
    uint<3> funct3 = cast(insn{14:12}, uint<3>);
    int<1> flipBit = insn{30:30};
    int<32> immI = cast(insn{31:20}, int<32>);
    int<32> immS = cast((insn{31:25} ++ insn{11:7}), int<32>);
    int<13> immBTmp = insn{31:31} ++ insn{7:7} ++ insn{30:25} ++ insn{11:8} ++ 0<1>;
    int<16> immB = cast(immBTmp, int<16>);
    int<21> immJTmp = insn{31:31} ++ insn{19:12} ++ insn{20:20} ++ insn{30:21} ++ 0<1>;
    int<32> immJ = cast(immJTmp, int<32>);
    int<12> immJRTmp = insn{31:20};
    int<16> immJR = cast(immJRTmp, int<16>);
    int<32> immU = insn{31:12} ++ 0<12>;
    bool isOpImm = opcode == 0b0010011<7>;
    bool flip = (!isOpImm) && (flipBit == 1<1>);
    bool isLui   = opcode == 0b0110111<7>;
    bool isAui   = opcode == 0b0010111<7>;
    bool isOp    = opcode == 0b0110011<7>;
    bool isJal   = opcode == 0b1101111<7>;
    bool isJalr  = opcode == 0b1100111<7>;
    bool isBranch = opcode == 0b1100011<7>;
    bool isStore = opcode == 0b0100011<7>;
    bool isLoad = opcode == 0b0000011<7>;
    bool isMDiv = (funct7 == u1<7>) && isOp;
    bool needrs1 = !isJal;
    bool needrs2 = isOp || isBranch || isStore || isJalr;
    bool writerd = (rd != u0<5>) && (isOp || isOpImm || isLoad || isJal || isJalr || isLui || isAui);
    start(rf);
    if (needrs1) {
       acquire(rf[rs1], R);
       int<32> rf1 = rf[rs1];
       release(rf[rs1]);
    } else {
      int<32> rf1 = 0<32>;
    }
    if (needrs2) {
       acquire(rf[rs2], R);
       int<32> rf2 = rf[rs2];
       release(rf[rs2]);
    } else {
       int<32> rf2 = 0<32>;
    }
    if (writerd) {
       reserve(rf[rd], W);
    }
    end(rf);
    ---
    if (isBranch) {
       int<16> npc = br(pc, immB, funct3, rf1, rf2);
    } else {
    if (isJal) {
       //divide by 4 since it counts bytes instead of insns
       int<32> npc32 = cast(pc, int<32>) + (immJ >> 2);
       int<16> npc = npc32{15:0};
    } else {
    if (isJalr) {
       int<16> npc = (rf1{15:0} + immJR) >> 2;
    } else {
       int<16> npc = pc + 1<16>;
    }}}
    if (!done) { call cpu(npc); }
    int<32> alu_arg2 = (isOpImm) ? immI : rf2;
    split {
    	  case: (isLui) {
	  	int<32> alu_res = immU;
	  }
	  case: (isAui) {
	  //all pc computation needs to be multiplied by 4
	  	int<32> pc32 = (0<16> ++ pc) << 2;
	  	int<32> alu_res = pc32 + immU;
	  }
	  case: (isMDiv) {
	  	int<32> mout = mul(rf1, rf2, funct3); //TODO handle DIV
	  	int<32> alu_res = mout;
	  }
	  default: {
	        int<32> alu_res = alu(rf1, alu_arg2, funct3, flip);
	  }
    }
    if (isStore) {
            //addresses also are word-sized
       int<32> tmp = (immS + rf1) >> 2;
       int<16> memaddr = tmp{15:0};
    } else {
    if (isLoad) {
        //addresses also are word-sized    
       int<32> tmp = (immI + rf1) >> 2;
       int<16> memaddr = tmp{15:0};
    } else {
      int<16> memaddr = 0<16>;
    }}
    ---
    if (isStore || isLoad) {
        start(dmem);
	if (isLoad) {
 	   uint<16> raddr = cast(memaddr, uint<16>);
	   acquire(dmem[raddr], R);
	   int<32> wdata <- dmem[raddr];
	   release(dmem[raddr]);
	   ---
	} else {
	    uint<16> waddr = cast(memaddr, uint<16>);
	    acquire(dmem[waddr], W);
	    dmem[waddr] <- rf2;
	    release(dmem[waddr]);
    	    ---
    	    int<32> wdata = 0<32>;
	}
	end(dmem);
    } else {
      ---
      int<32> wdata = 0<32>;
    }
    print("PC: %h", pc << 2);
    print("INSN: %h", insn);
    if (writerd) {
       block(rf[rd]);
       if (isLoad) {
       	  int<32> insnout = wdata;
       } else {
       if (isJal || isJalr) {
       	  //need to multiply by 4 b/c it is arch visible.
	  int<16> nextpc = pc + 1<16>;
	  int<32> insnout =  0<16> ++ (nextpc << 2); //todo make pc 32 bits
       } else {
       	 int<32> insnout = alu_res;
       }}
       print("Writing %d to r%d", insnout, rd);
       rf[rd] <- insnout;
       release(rf[rd]);
    }
    if (done) { output(true); }
}

circuit {
    ti = memory(int<32>, 16);
    i = Queue(ti);
    td = memory(int<32>, 16);
    d = FAQueue(td);
    rf = regfile(int<32>, 5);
    r = FAQueue(rf);
    c = new cpu[r, i, d];
    call c(0<16>);
}
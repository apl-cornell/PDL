def alu(arg1: int<32>, arg2: int<32>, op: int<3>, flip: bool): int<32> {
    uint<5> shamt = cast(arg2{4:0}, uint<5>);
    if (op == 0<3>) {  //000 == ADD , flip == sub
       if (!flip) {
         return arg1 + arg2;
       } else {
         return arg1 - arg2;
       }
    } else {
    if (op == 1<3>) { //001 == SLL
        return arg1 << shamt;
    } else {
    if (op == 2<3>) { //010 == SLT 
        return (arg1 < arg2) ? 1<32> : 0<32>;
    } else {
    if (op == 3<3>) { //011 == SLTU
       uint<32> un1 = cast(arg1, uint<32>);
       uint<32> un2 = cast(arg2, uint<32>);
       return (un1 < un2) ? 1<32> : 0<32>;
    } else {
    if (op == 4<3>) { //100 == XOR
        return arg1 ^ arg2;
    } else {
    if (op == 5<3>) { //101 == SRL / SRA
      if (!flip) {
        return cast((cast(arg1, uint<32>)) >> shamt, int<32>); //SRL
      } else {
        return arg1 >> shamt; //SRA
      }
    } else {
    if (op == 6<3>) { //110 == OR
        return arg1 | arg2;
    } else { //111 == AND
        return arg1 & arg2;
    }}}}}}}
    
}

def br(pc: int<16>, off:int<16>, op:int<3>, arg1:int<32>, arg2:int<32>): int<16> {
    //divide by 4 b/c we count instructions not bytes
    int<16> offpc = pc + (off >> 2);
    int<16> npc = pc + 1<16>;
    if (op == 0<3>) { //BEQ
        if (arg1 == arg2) { return offpc; } else { return npc; }
    } else {
    if (op == 1<3>) { //BNE
       if (arg1 != arg2)  { return offpc; } else { return npc; }
    } else {
    if (op == 4<3>) { //BLT
       if (arg1 < arg2)  { return offpc; } else { return npc; }
    } else {
    if (op == 5<3>) { //BGE
       if (arg1 >= arg2)  { return offpc; } else { return npc; }
    } else {
    if (op == 6<3>) { //BLTU
       if (arg1 < arg2)  { return offpc; } else { return npc; } //todo unsigned
    } else {
    if (op == 7<3>) { //BGEU
       if (arg1 >= arg2) { return offpc; } else { return npc; } //todo unsigned
    } else {
      return npc;
    }}}}}}
}


pipe cpu(pc: int<16>)[rf: int<32>[5]<c,s>(FAQueue), imem: int<32>[16]<a,a>(Queue), dmem: int<32>[16]<a,a>(FAQueue)] {
    start(imem);
    acquire(imem);
    int<16> debugpc = pc << 2;
    print(debugpc);
    int<32> insn <- imem[cast(pc, uint<16>)];
    release(imem);
    end(imem);
    ---
    print(insn);
    int<7> opcode = insn{6:0};
    uint<5> rs1 = cast(insn{19:15}, uint<5>);
    uint<5> rs2 = cast(insn{24:20}, uint<5>);
    uint<5> rd = cast(insn{11:7}, uint<5>);
    int<7> funct7 = insn{31:25};
    int<3> funct3 = insn{14:12};
    int<1> flipBit = insn{30:30};
    int<32> immI = cast(insn{31:20}, int<32>);
    int<32> immS = cast((insn{31:25} ++ insn{11:7}), int<32>);
    int<13> immBTmp = insn{31:31} ++ insn{7:7} ++ insn{30:25} ++ insn{11:8} ++ 0<1>;
    int<16> immB = cast(immBTmp, int<16>);
    int<21> immJTmp = insn{31:31} ++ insn{19:12} ++ insn{20:20} ++ insn{30:21} ++ 0<1>;
    int<32> immJ = cast(immJTmp, int<32>);
    int<12> immJRTmp = insn{31:20};
    int<16> immJR = cast(immJRTmp, int<16>);
    int<32> immU = insn{31:12} ++ 0<12>;
    bool isOpImm = opcode == 0b0010011<7>;
    bool flip = (!isOpImm) && (flipBit == 1<1>);
    bool isLui   = opcode == 0b0110111<7>;
    bool isAui   = opcode == 0b0010111<7>;
    bool isOp    = opcode == 0b0110011<7>;
    bool isJal   = opcode == 0b1101111<7>;
    bool isJalr  = opcode == 0b1100111<7>;
    bool isBranch = opcode == 0b1100011<7>;
    bool isStore = opcode == 0b0100011<7>;
    bool isLoad = opcode == 0b0000011<7>;
    bool needrs1 = !isJal;
    bool needrs2 = isOp || isBranch || isStore || isJalr;
    bool writerd = (rd != u0<5>) && ((opcode{6:5} == 0<2>) || isJal || isJalr || isLui || isAui);
    start(rf);
    if (needrs1) {
       acquire(rf[rs1], R);
       int<32> rf1 = rf[rs1];
       release(rf[rs1]);
    } else {
      int<32> rf1 = 0<32>;
    }
    if (needrs2) {
       acquire(rf[rs2], R);
       int<32> rf2 = rf[rs2];
       release(rf[rs2]);
    } else {
       int<32> rf2 = 0<32>;
    }
    if (writerd) {
       reserve(rf[rd], W);
    }
    end(rf);
    ---
    if (isBranch) {
       int<16> npc = br(pc, immB, funct3, rf1, rf2);
    } else {
    if (isJal) {
       //divide by 4 since it counts bytes instead of insns
       int<32> npc32 = cast(pc, int<32>) + (immJ >> 2);
       int<16> npc = npc32{15:0};
    } else {
    if (isJalr) {
       int<16> npc = (rf1{15:0} + immJR) >> 2;
    } else {
       int<16> npc = pc + 1<16>;
    }}}
    call cpu(npc);
    int<32> alu_arg2 = (isOpImm) ? immI : rf2;
    split {
    	  case: (isLui) {
	  	int<32> alu_res = immU;
	  }
	  case: (isAui) {
	  	int<32> pc32 = 0<16> ++ pc;
	  	int<32> alu_res = pc32 + immU;
	  }
	  default: {
	        int<32> alu_res = alu(rf1, alu_arg2, funct3, flip);
	  }
    }
    if (isStore) {
       int<32> tmp = (immS + rf1);
       int<16> memaddr = tmp{15:0};
    } else {
    if (isLoad) {
       int<32> tmp = (immI + rf1);
       int<16> memaddr = tmp{15:0};
    } else {
      int<16> memaddr = 0<16>;
    }}
    ---
    if (isStore || isLoad) {
        start(dmem);
	if (isLoad) {
 	   uint<16> raddr = cast(memaddr, uint<16>);
	   acquire(dmem[raddr], R);
	   int<32> wdata <- dmem[raddr];
	   release(dmem[raddr]);
	   ---
	} else {
	    uint<16> waddr = cast(memaddr, uint<16>);
	    acquire(dmem[waddr], W);
	    dmem[waddr] <- rf2;
	    release(dmem[waddr]);
    	    ---
    	    int<32> wdata = 0<32>;
	}
	end(dmem);
    } else {
      ---
      int<32> wdata = 0<32>;
    }
    if (writerd) {
       block(rf[rd]);
       if (isLoad) {
       	  rf[rd] <- wdata;
       } else {
       if (isJal || isJalr) {
       	  //need to multiply by 4 b/c it is arch visible.
	  int<16> nextpc = pc + 1<16>;
       	  rf[rd] <- 0<16> ++ (nextpc << 2); //todo make pc 32 bits
       } else {
       	  rf[rd] <- alu_res;
       }}
       release(rf[rd]);
    }    
}

circuit {
    ti = memory(int<32>, 16);
    i = Queue(ti);
    td = memory(int<32>, 16);
    d = FAQueue(td);
    rf = regfile(int<32>, 5);
    r = FAQueue(rf);
    c = new cpu[r, i, d];
    call c(0<16>);
}
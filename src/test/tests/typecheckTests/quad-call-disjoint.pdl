pipe quad_call(inpt: uint<32>)[rf: int<32>[5]<c, s>] {
   bool a = inpt{0:0};
   bool b = inpt{1:1};
   if(a && b)
     {
       call quad_call(inpt);
     }
   ---
   if(a && !b)
     {
       call quad_call(inpt);
     }
   ---
   if((!a) && b)
     {
       call quad_call(inpt);
     }
   ---
   if((!a) && (!b))
     {
       call quad_call(inpt);
     }
}

pipe comparison(inpt: int<32>, bool1: bool, bool2: bool)[rf: int<32>[5]<c, s>]
{
  int<16> a = inpt{0:15};
  int<16> b = inpt{16:31};
  bool lt = a < b;
  bool eq = a == b;
  split {
    case: bool1
      {
        call comparison(inpt, bool2, bool1);
      }
    case: bool2
      {
        call comparison(inpt + 1<32>, bool1, bool2);
      }
    case: (inpt{0:0} == 1)
      {
        call comparison(inpt - 1<32>, bool2, bool1);
      }
    default:
      {
        call comparison(inpt, bool1, bool2);
      }
  }
}

pipe getFalse()[] :bool
{
  output(false);
}

//at least it is smart about else lol
pipe test1(inpt: int<32>)[rf: int<32>[5]]
  {
    if(inpt{0:0} == 1)
      {
        call test1(inpt);
      } else
      {
        call test1(inpt);
      }
      ---
      
    call getFalse();
}

pipe very_simple()[]
  {
    call very_simple();
  }

pipe falsification()[]
  {
    if(false)
      {
        call very_simple();
      } else
      {
        call falsification();
      }
  }

circuit
  {
    r = memory(int<32>, 5);
  }
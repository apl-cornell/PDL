package pipedsl.passes

import pipedsl.common.DAGSyntax.PStage
import pipedsl.common.Errors.UnexpectedCommand
import pipedsl.common.Locks._
import pipedsl.common.Syntax
import pipedsl.common.Syntax._
import pipedsl.common.Utilities.{flattenStageList, updateListMap}
import pipedsl.passes.Passes.StagePass

/**
 * This pass converts the high level (syntax-level) lock operations
 * into the operational realization of lock operations. Specifically,
 * this involves generating variables to represent the lock state information
 * held by the Thread. Reserve statements will produce these 'handles' which
 * must be passed to future operations like 'block' and 'release'
 *
 * This additionally annotates memory accesses with the appropriate lock handle variable,
 * s.t. implementations that feed the memory accesses through the lock API have the information
 * they need to generate code.
 */
object LockOpTranslationPass extends StagePass[List[PStage]] {


  private def lockVar(l: LockArg): EVar = {
    val lockname = "_lock_id_" + l.id.v + (if (l.evar.isDefined) "_" + l.evar.get.id.v else "")
    val res = EVar(Id(lockname))
    res.typ = Some(TRequestHandle(l.id, isLock = true))
    res.id.typ = res.typ
    res
  }

  override def run(stgs: List[PStage]): List[PStage] = {
    flattenStageList(stgs).foreach(s => {
      eliminateLockRegions(s)
      translateLockOps(s)
    })
    stgs
  }

  /**
   * Replace the existing lock ops where necessary.
   * Specifically, add in "lock check" commands that block
   * until the lock is acquirable and remove the "acquire"
   * commands that are unnecessary thanks to the lock already being "reserved"
   * @param stg - The stage to modify
   */
  private def translateLockOps(stg: PStage): Unit = {
    val (lockCmds, notlockCmds) = stg.getCmds.partition { case _: CLockOp => true; case _ => false }
    val lockmap = lockCmds.foldLeft(Map[LockArg, List[Command]]())((m, lc) => lc match {
      case c@CLockOp(mem, _, _) => updateListMap(m, mem, translateOp(c))
      case _ => throw UnexpectedCommand(lc)
    })
    val newlockcmds = lockmap.keys.foldLeft(List[Command]())((cs, lid) => {
      cs ++ mergeLockOps(lid, lockmap(lid))
    })
    notlockCmds.foreach(c => annotateMemOps(c))
    stg.setCmds(notlockCmds ++ newlockcmds)
  }

  //TODO once the Lock Type checking gets more advanced this may not
  //correctly match up lock handle variables (those generated by 'reserve statements')
  //with their memory access expressions
  private def annotateMemAccess(e: Expr): Unit = e match {
    case em@EMemAccess(mem, _) if em.granularity == General =>
      em.lockHandleArg = Some(lockVar(LockArg(mem, None)))
      //SimplifyRecvPass ensures that the index expression is always a variable
    case em@EMemAccess(mem, idx@EVar(_)) if em.granularity == Specific =>
      em.lockHandleArg = Some(lockVar(LockArg(mem, Some(idx))))
    case _ => ()
  }

  private def annotateMemOps(c: Command): Unit = c match {
      //SimplifyRecvPass ensures that rhs is always a MemAccess xor a complex expression w/o memaccesses
    case CAssign(lhs, rhs) => annotateMemAccess(rhs); annotateMemAccess(lhs)
    case CRecv(lhs, rhs) => annotateMemAccess(rhs); annotateMemAccess(lhs)
    //lhs should not contain _any_ memaccesses thanks to the ConvertAsyncPass (but adding this doesn't hurt)
    case CExpr(exp) => annotateMemAccess(exp)
    case im@IMemSend(_, _, mem, _, _) if im.granularity == General =>
      im.lockHandleArg = Some(lockVar(LockArg(mem, None)))
    case im@IMemSend(_, _, mem, _, addr) if im.granularity == Specific =>
      im.lockHandleArg = Some(lockVar(LockArg(mem, Some(addr))))
    case im@IMemWrite(mem, _, _) if im.granularity == General =>
      im.lockHandleArg = Some(lockVar(LockArg(mem, None)))
    case im@IMemWrite(mem, addr, _) if im.granularity == Specific =>
      im.lockHandleArg = Some(lockVar(LockArg(mem, Some(addr))))
    case _ => ()
  }

  private def translateOp(c: CLockOp): Command = {

  //TODO make this cleaner lol
    c.op match {
      case Free => {
        val i = ICheckLockFree(c.mem)
        i.memOpType = c.memOpType
        i.granularity = c.granularity
        i
      }
      case Reserved => {
        val i = IReserveLock(lockVar(c.mem), c.mem)
        i.memOpType = c.memOpType
        i.granularity = c.granularity
        i
      }
      case Acquired => {
        val i = ICheckLockOwned(c.mem, lockVar(c.mem))
        i.memOpType = c.memOpType
        i.granularity = c.granularity
        i
      }
      case Released => {
        val i = IReleaseLock(c.mem, lockVar(c.mem))
        i.memOpType = c.memOpType
        i.granularity = c.granularity
        i
      }
    }

  }

}

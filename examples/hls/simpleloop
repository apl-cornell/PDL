/*
s = 0;
for(int i = 0; i < 100; i++) {
  d = A[i] - B[i];
  if (d > 0) {
    s += d;
  }
}
return s;
*/

pipe sum(counter: int<7>)[memA: int<30>[7]<a,a>, memB: int<30>[7]<a,a>, total: int<30>[1]<c,s>] {
    if (counter < 100<7>) {
        call sum(counter + 1<7>);
        //acquire(memA[counter]);
        start(memA);
        acquire(memA);
        end(memA);
        start(memB);
        acquire(memB);
        end(memB);
        int<30> argA <- memA[counter];
        int<30> argB <- memB[counter];
        //release(memA[counter]);
        release(memA);
        //release(memB[counter]);
        release(memB);
        ---
        int<30> d = 1<30>; //could split into multiple cycles as in HLS examples
        if (d > 0<30>) {
            ---
            start(total);
            acquire(total);
            end(total);
            int<30> s = total[0] + d; //could split into multiple cycles as in HLS
            print(s);
            total[0] <- s;
            release(total);
        }
    } //else done, do nothing
}

/*
    start(total);
    reserve(total[0]);
    int<32> t0 = bypass(total[0]);
    int<32> s = t0 + d;
    end(total);
    ---
    acquire(total[0]);
    total[0] <- s;
    release(total);

*/
circuit {
    total = regfile(int<30>, 1);
    memA = memory(int<30>, 7);
    memB = memory(int<30>, 7);
    s = new sum[memA, memB, total];
    call s(0<7>);
}
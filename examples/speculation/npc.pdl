spec pipe cpu(pc: int<32>)[rf, imem, dmem] {
 insn <- imem[pc];
 sid <- spec call cpu(pc + 4); //creates entry indexed by sid, stores pc + 4);
 ---
 rs1 = insn{4:0};
 //etc
 arg1 = rf[rs1];
 ---
 npc = brUnit(arg1, arg2, pc, op);
 spec_barrier(); //must be sure that I'm not speculative before verifying speculation I caused
 /*
  shouldKill = checkSpec(_thread_sid_); //"free"s entry in spec table
  if (shouldKill) {
     kill(); //stop executing this thread
  } else { NOP} 
  */
 
 mispredict = verify call cpu(npc, sid); //updates spec entry w/ mispredict bit
 /* want this to be implicit
 if (mispredict) {
    call cpu(npc);
 } */
 /* want this to be specifiable by the programmer in _some_ way */
 update_bpred(pc, npc, mispredict);
 ---
 //mem stage
 ---
 if (isWB) {
    rf[rd] <- result;
 }
}

//in normal pipeline: just _always_ call cpu(pc + 4) in stage 1.
//in stage 3, if npc != pc + 4, then kill stage 1 and stage 2 AND call cpu(pc + 4)


//what can _not_ be done speculatively?
  //writing to memory
  //mark own speculative events as non-speculative ??
  //create nested speculation ????


//how to resolve speculation?
  //check my own entry in a table (and free it!)





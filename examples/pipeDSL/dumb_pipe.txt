# === comment
// === clock cycle boundary
=  === blocking write (a.k.a combinational logic, w/in a clock cycle)
<- === non-blocking write (a.k.a register or memory update, is visible next clock cycle)

#This block is the dest of definitions for instantiating the cpu
def cpu {
    #some pseudo syntax here for defining the units in our datapath
    imem = new cache<insn>();
    rf = new regfile();
    dmem = new cache<data>();
    alu = new arith_unit();
    bpred = new branch_pred();
}

#This is a stupid CPU which has pipelining (i.e., the //
indicate that we put clock cycle boundaries between operations).
However, there is no parallelism from the pipelinining since
we don't recursively call "cpu" until the very end of computation
(the return statement).

cpu(pc) {

  imem.send(pc);
  //
  insn = imem.recv(pc); #should the receive take an argument for disambiguation?
  #could re-write the above three lines as: insn <- imem(pc); //

  op = opcode(insn); #selects some bits from the instruction

  rs1 = rs1(insn);
  rs2 = rs2(insn);
  dest = dest(insn);

  npc = match (opcode) #check the opcode bits {
    case BR: {
    	 rf.send(R, rs1); #send read request
	 rf.send(R, rs2);
	 //
	 arg1 = rf.recv(rs1);
	 arg2 = rf.recv(rs2);
	 #similarly, these lines could be: arg1 <- rf(rs1); arg2 <- rf(rs2); //
	 take_br = br_unit(insn, arg1, arg2) # checks the kind of comparison and executes it
	 if (take_br) {
	   pc + imm(insn);
         } else {
	   pc + 4;
         }
    }
    case ARITH: {
      arg1 <- rf(R, rs1);
      arg2 <- rf(R, rs2);
      //
      #decided to use the alternate syntax for this case
      alu.send(arg1, arg2, aop(insn))
      res = alu.recv()
      rf.send(W, res, dest);
      // #need to wait for the write to go through so that it is visible to next iteration.
      pc + 4;
    }
    case LD: {
      addr <- rf(R, rs1);
      //
      dmem.send(R, addr + imm(insn));
      //
      val = dmem.recv();
      rf.send(val, dest);
      //
      pc + 4;   
    }
    case ST: {
      addr <- rf(R, rs1);
      val <- rf(R, rs2);
      //
      dmem.send(W, addr + imm(insn), val);
      //
      pc + 4;
    }
    case NOP: {
      pc + 4;
    }
    return cpu(npc);
  }
}

#actually instantiate and inintialize the cpu
main {
  cpu = new cpu();
  cpu.send(0);
}
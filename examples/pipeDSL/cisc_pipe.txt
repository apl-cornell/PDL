# === comment
// === clock cycle boundary
=  === blocking write (a.k.a combinational logic, w/in a clock cycle)
<- === non-blocking write (a.k.a register or memory update, is visible next clock cycle)

#This block is the dest of definitions for instantiating the cpu
def cpu {
    #some pseudo syntax here for defining the units in our datapath
    imem = new cache<insn>();
    rf = new regfile();
    dmem = new cache<data>();
    alu = new arith_unit();
    bpred = new branch_pred();
}

#This implements a CISC ISA where instructions are of the form <op> <arg1> <arg2>
#Where args can be register indices or memory locations (depending on a few bits in arg1 and arg2)
#This implementation maybe serializes the reads to its operations, assuming it has a memory
#which can only support executing 1 read request per cycle

cpu(pc) {

  insn <- imem.send(pc);
  //
  op = opcode(insn); #selects some bits from the instruction
  rs1 = rs1(insn);
  rs2 = rs2(insn);
  dest = rs2;
  if (op == BR) {
     arg1 <- rf.read1(rs1);
     arg2 <- rf.read2(rs2);
     //
     take_br = br_unit(insn, arg1, arg2) # checks the kind of comparison and executes it     
     if (take_br) {
     	return cpu(pc + imm(insn));
     } else {
        return cpu(pc + 4);
     }
  } else {
     spawn cpu(pc + 4);
     arg1 <- match (rs1) {
       case REGISTER: {
         rf.read1(rs1);
       }
       case MEMORY: {
        dmem.read(rs1);
       }
     }
     // #need break here b/c dmem only has 1 port
     arg2 <- match (rs2) {
       case REGISTER: {
         rf.read2(rs2);
       }
       case MEMORY: {
         dmem.read(rs2);
       }
     }
     //
     res <- alu(arg1, arg2, op);
     //
     match (dest) {
       case REGISTER: {
         rf.write(dest, res);
       }
       case MEMORY: {
         dmem.write(dest, res);
       }
     }
  }
}

#actually instantiate and inintialize the cpu
main {
  cpu = new cpu();
  cpu.send(0);
}

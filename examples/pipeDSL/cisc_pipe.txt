# === comment
// === clock cycle boundary
=  === blocking write (a.k.a combinational logic, w/in a clock cycle)
<- === non-blocking write (a.k.a register or memory update, is visible next clock cycle)

#This block is the dest of definitions for instantiating the cpu
def cpu {
    #some pseudo syntax here for defining the units in our datapath
    imem = new cache<insn>();
    rf = new regfile();
    dmem = new cache<data>();
    alu = new arith_unit();
    bpred = new branch_pred();
}

#This implements a CISC ISA where instructions are of the form <op> <arg1> <arg2>
#Where args can be register indices or memory locations (depending on a few bits in arg1 and arg2)
#This implementation maybe serializes the reads to its operations, assuming it has a memory
#which can only support executing 1 read request per cycle

cpu(pc) {

  insn <- imem.send(pc);
  ---
  op = opcode(insn); #selects some bits from the instruction
  rs1 = rs1(insn);
  rs2 = rs2(insn);
  dest = dest(insn);
  call cpu(pc + 4);
  if (rs1 == MEM || rs2 == MEM) {
    dmem.acquire();
  }
  if (rs1 == RF) {
    rf[rs1].acquire();
  }
  if (rs2 == RF) {
    rf[rs2].acquire();
  }
  if (dest == MEM) {
    dmem.reserve();
  } else {
    rf[dest].reserve();
  }
  arg1 <- (rs1 == MEM) ? dmem.read(rs1) : rf.read(rs1);
  ---
  arg1 <- (rs2 == MEM) ? dmem.read(rs1) : rf.read(rs2);
  ---
  res <- alu(arg1, arg2, op);
  ---
  if (dest == MEM) {
     dmem.write(dest, res);
  } else {
     rf.write(dest, res);
  }
}

#actually instantiate and inintialize the cpu
main {
  cpu = new cpu();
  cpu.send(0);
}

pipe cpu(pc: int<16>)[rf: int<32>[5]<c,s>, imem: int<32>[16]<a,a>] {
    if (pc < 14<16>) {
        call cpu(pc + 1<16>);
    }
    start(imem);
    acquire(imem);
    int<32> insn <- imem[pc];
    release(imem);
    end(imem);
    ---
    int<2> op = insn{1:0};
    int<5> rs1 = insn{6:2};
    int<5> rs2 = insn{11:7};
    int<5> rd = insn{16:12};
    start(rf);
    acquire(rf[rs1], r); //turns into just a check that no outstanding writes
    int<32> rf1 = rf[rs1];
    release(rf[rs1]);
    reserve(rf[rs2], r); //reserve read lock (prevents acquisition of write lock? or does nothing ?)
    reserve(rf[rd], w); //reserve write lock
    /*
    reserve(addr, w) => returns new physical address (unused index from circular buffer)
                        blocks if circular buffer is full
                        updates "read map" (i.e. which physical address read requests go to)
    reserve(addr, r) => returns correct physical address

    block(addr, w) => is this necessary?
    block(addr, r) => checks to see if they physical entry (obtained from reserve) had valid data yet

    release(addr, w) => allows new thread to re-use the physical address?
    release(addr, r) => not...sure
    */
    end(rf);
    ---
    block(rf[rs2]);
    int<32> rf2 = rf[rs2];
    release(rf[rs2]);
    ---
    int<32> res = rf1 + rf2;
    ---
    block(rf[rd]);
    print(res);
    rf[rd] <- res;
    release(rf[rd]);
    ---
}

/*
    reserve(rf[rs1], r); //create entry in queue
    reserve(rf[rs2]); //create entry in queue
    reserve(rf[rd]); //create entry in queue
    ---
    block(rf[rs1]); //wait until entry is head of queue
    x = bypass(rf[rs1]); //OR until prior entry has valid data
    release(rf[rs1]); //what do if not at head of queue?
    ---
    block(rf[rs1]); //same as prior
    y = rf[rs2];
    release(rf[rs2]);
    ---
    o = x + y;
    commit(rf[rd], o); //write data to queue
    ---
    block(rf[rd]); //wait until at head of queue
    rf[rd] <- o;
    release(rf[rd]); //free queue entry
*/
circuit {
 i = memory(int<32>, 16);
 r = regfile(int<32>, 5);
 c = new cpu[r, i];
 call c(0<16>);
}
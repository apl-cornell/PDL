\documentclass{article}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{ttquot}
\usepackage{pl-syntax}
\newcommand{\step}[0]{\ensuremath{\rightarrow}}
\newcommand{\bstep}[0]{\ensuremath{\Downarrow}}
\newcommand{\pstep}[0]{\ensuremath{\rightarrow_{\mathcal{S}}}}
\newcommand{\skips}[0]{~\textsf{skip}~}
\newcommand{\outputs}[0]{~\textsf{output}~}
\newcommand{\spawns}[0]{~\textsf{spawn}~}
\newcommand{\bop}{~\textsf{bop}~}
\newcommand{\uop}{~\textsf{uop}~}
\makeatletter
\newcommand{\conf}[1]{\langle #1\@confx}
\newcommand\@confx{\@ifnextchar\stopconf{\@confend}{\@confi}}
\newcommand\@confend[1]{\rangle}
\newcommand\@confi[1]{,#1 \@confx}
\makeatother

\begin{document}

\title{Sequential Semantics for Pipeline DSL}
\author{Drew Zagieboylo}
\maketitle

\section{MetaVariables}
\begin{align*}
  \begin{array}{lc}
    \mbox{Integers} & n \\
    \mbox{Variables} & v,f\\
    \mbox{Expressions} & e\\
    \mbox{Statements} & c\\
    \mbox{Functions} & \mathcal{F}\\
    \mbox{Objects} & \mathcal{O}\\
  \end{array}
\end{align*}

Program: List of Modules and Initial Conditions
Module: List of Stages, List of Locks, List of Formal Parameters (used to set initial conditions)
Lock: A special lock object with a few methods (acquire(), release(), reserve())
Stage: A set of receive statements, combinations assignments and guarded send statements
Input: Valid Bit, 
Commands: Limited IMP (no loops) + Barrier Statements
Barrier: Lock Name
Message: Module, Message Contents
Message Contents: Function Name, List of Arguments

\begin{figure}[h]
\begin{syntax}
  \abstractCategory[Variables]{v, x, z}
  \abstractCategory[Integers]{n, m}
  \abstractCategory[Locks]{L}
  \abstractCategory[Channels]{C}
  
  \category[Programs]{P}
  \alternative{ \{ List(M), List(v \mapsto n) \}} %Set of module declarations, Set of module instantiations, Set of Initial Conditions for each instantiated module

  \category[Modules]{M}
  \alternative{ \{List(S), List(L), List(v)\}} %List of stages, first element is root stage; List of Locks; List of formal parameters set by initial conditions

  \category[Stages]{S}
  \alternative{ \{List("pred"), "com", List("succ") \}}

  \category[Expressions]{e}
  \alternative{ e " binop " e }
  \alternativeLine{ " unop " e }
  \alternativeLine{ e " ? " e " : " e }
  \alternativeLine{ v }
  \alternative{ n }
  \alternative{ b }

  \category[Predecessors]{"pred"}
  \alternative{ v = "recv " C }

  \category[Commands]{"com"}
  \alternative{ "skip" }
  \alternative{ "com " ; " com" }
  \alternative{ v = e }
  \alternativeLine{ L".acquire()"}
  \alternative{ L".release()"}
  \alternative{ L".reserve()"}

  \category[Successors]{"succ"}
  \alternative{ "if ("v") send(" v, C")" }

\end{syntax}
\end{figure}
\section{Notes}

This language consists of a DAG of pipeline stages.
Each stage can be _occupied_ or _unoccupied_ and _active_ or _inactive_.
Occupied stages contain valid pipeline data from a prior
pipeline stage.
Active stages have received all of their inputs (from both
pipeline stages and other modules).
Every cycle, each _active_ stage executes its commands
and sends data to each of its ready successors (for that execution path).
Once a stage has sent data to all of its successors (for that execution path),
then it becomes unoccupied and invalid.
The semantics allow for "short-circuiting" such that a stage which is
becoming unoccupied can still receive data and remain occupied in the next cycle.

Additionally, this language has a notion of locks or barriers,
which provide further requirements before a stage can become active.
For instance, some stage may execute a command that acquires a read-lock
on a memory and then also execute a command to read that memory. Or it may
simply acquire the lock without reading the memory. They are separate commands.

\begin{figure}
  \[\begin{array}{r|l} \hline
    \text{Variable Mappings} & \Sigma: S \rightarrow \sigma \\
    \text{State Variable Mappings} & \sigma: v \rightarrow n \\
    \text{Receive Status} & \Pi: S \rightarrow \pi \\
    \text{State Receive Status} & \pi: C \rightarrow b \\
    \text{Send Status} & \Delta: S \rightarrow C \rightarrow b \\
    \text{State Send Status} & \delta: C \rightarrow b \\ \hline
  \end{array}\]
  \caption{Environment Types}
\end{figure}

\section{Operational Semantics}
Expression Semantics
\begin{mathpar}
  \inferrule*[Left={Uop}]{\conf{\sigma}{e}\stopconf \bstep n' \\ \uop n' = n''}
             {\conf{\sigma}{\uop n}\stopconf \bstep n''}\\
  \inferrule*[Left={Binop}]{\conf{\sigma}{e_1}\stopconf \bstep n \\ \conf{\sigma}{e_2}\stopconf \bstep n' \\ n \bop n' = n''}
             {\conf{\sigma}{e_1 \bop e_2}\stopconf \bstep n''}\\
  \inferrule*[Left={Int-Lookup}]{\sigma(v) = n}{\conf{\sigma}{v}\stopconf \bstep n}\\
  \inferrule*[Left={Ternary}]{\conf{\sigma}{e_b}\stopconf \bstep n_c \\ \conf{\sigma}{e_t}\stopconf \bstep n_t \\
  \conf{\sigma}{e_f}\stopconf \bstep n_f \\ n_c \neq 0 " ? " n_t " : " n_f}
             {\conf{\sigma}{e_b " ? " e_t " : " e_f}\stopconf \bstep n}\\
\end{mathpar}
Receive Semantics
\begin{mathpar}
  \inferrule*[Left={Block-Recv}]{ C.isEmpty() " or " \pi(C) = "true"}
             {\conf{\sigma}{\pi}{v = "recv " C}\stopconf \step \conf{\sigma}{\pi}\stopconf}\\
  \inferrule*[Left={Accept-Recv}]{!C.isEmpty() \\ \pi(C) = "false" \\ \sigma' = \sigma[v \mapsto C.pop()] \\
    \pi' = \pi[C \mapsto "true"]}
             {\conf{\sigma}{v = "recv " C}\stopconf \step \conf{\sigma'}{\pi'}\stopconf}\\
  \inferrule*[Left={Recv-List}]{
    \mathcal{P} = \{"pred"_0..."pred"_n\} \\
    \forall p \in \mathcal{P}. \conf{\sigma}{\pi}{p}\stopconf \step \conf{\sigma_p'}{\pi_p'}\stopconf \\
    \sigma' = \bigcup_{p \in \mathcal{P}} \sigma_p' \\ \pi' = \bigcup_{p \in \mathcal{P}} \pi_p'}
             {\conf{\sigma}{\pi}{\mathcal{P}}\stopconf \step \conf{\sigma'}{\pi'}\stopconf}\\
\end{mathpar}

Command Semantics
\begin{mathpar}
  \inferrule*[Left={Seq-Skip}]{ }
             {\conf{\sigma}{\skips ; "com"_2}\stopconf \step \conf{\sigma}{"com"_2}\stopconf}\\
  \inferrule*[Left={Seq}]{ \conf{\sigma}{"com"_1}\stopconf \step \conf{\sigma'}{"com"_1'}\stopconf}
             {\conf{\sigma}{"com"_1" ; com"_2}\stopconf \step \conf{\sigma'}{"com"_1'" ; com"_2}\stopconf}\\
  \inferrule*[Left={Assign}]{ v \not\in "dom"(\sigma) \\ \conf{\sigma}{e}\stopconf \bstep n \\ \sigma' = \sigma[v \mapsto n]}
             {\conf{\sigma}{v = e}\stopconf \step \conf{\sigma'}{\skips}\stopconf}\\
\end{mathpar}
Send Semantics
\begin{mathpar}
  \inferrule*[Left={Send-Guard-True}]{  \sigma(v_g) \neq 0 }
             {\conf{\sigma}{\delta}{"if ("v_g") send(" v_v, C")"}\stopconf \step
               \conf{\sigma}{\delta}{"send(" v_v, C")"}\stopconf}\\
  \inferrule*[Left={Send-Guard-False}]{  \sigma(v_g) = 0  \\ \delta' = \delta[C \mapsto "true"]}
             {\conf{\sigma}{\delta}{"if ("v_g") send(" v_v, C")"}\stopconf \step \conf{\delta}\stopconf}\\
  \inferrule*[Left={Send-Blocked}]{ C.isFull() " or " \delta(C) = "true"}
             {\conf{\sigma}{\delta}{"send(" v_v, C")"}\stopconf \step \conf{\delta}\stopconf}\\
  \inferrule*[Left={Send}]{ !C.isFull() \\ \delta(C) = "false" \\ \delta' = \delta[C \mapsto "true"] \\ C.push(\sigma(v_v))}
             {\conf{\sigma}{\delta}{"send(" v_v, C")"}\stopconf \step \conf{\delta}\stopconf}\\
  \inferrule*[Left={Send-List}]
             { \mathcal{S} = \{"succ"_0..."succ"_n\} \\
               \forall s \in \mathcal{S}. \conf{\sigma}{\delta}{s}\stopconf \step^* \conf{\delta_s'}\stopconf \\
             \delta' = \bigcup_{s \in \mathcal{S}} \delta_s' }
             {\conf{\sigma}{\delta}{\mathcal{S}}\stopconf \step \conf{\delta'}\stopconf}\\
\end{mathpar}
Module Semantics
\begin{mathpar}
  \inferrule*[Left={Execute-Recvs}]{ \forall s \in S. \conf{\Sigma(s)}{\Pi(s)}{s."recv"}\stopconf \step
    \conf{\sigma_s'}{\pi_s'}\stopconf \\
    \Sigma' = \bigcup_{s\in S} \sigma_s' \\ \Pi' = \bigcup_{s \in S} \pi_s'}
             {\conf{\Sigma}{\Pi}{\Delta}{\{List(S), "recv"\}}\stopconf \step 
               \conf{\Sigma'}{\Pi'}{\Delta}{\{List(S), "exec"\}}\stopconf} \\
  \inferrule*[Left={Execute-Commands}]{\forall s \in S. \conf{\Sigma(s)}{s."com"}\stopconf \step^*
    \conf{\sigma_s'}{\skips}\stopconf \\ \forall s \in S. \Sigma'[s \mapsto \sigma_s']}
             {\conf{\Sigma}{\Pi}{\Delta}{\{List(S), "exec"\}}\stopconf \step
              \conf{\Sigma'}{\Pi}{\Delta}{\{List(S), "send"\}}\stopconf}\\
  \inferrule*[Left={Execute-Sends}]{\forall s \in S. \conf{\Sigma(s)}{\Delta(s)}{s."send"}\stopconf \step
    \conf{\delta_s'}\stopconf}
             {\conf{\Sigma}{\Pi}{\Delta}{\{List(S),"send"\}}\stopconf \step
             \conf{\Sigma}{\Pi}{\Delta'}{\{List(S), "endcycle"\}}\stopconf}\\
\end{mathpar}
\end{document}

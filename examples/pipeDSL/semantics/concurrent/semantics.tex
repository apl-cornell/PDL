\documentclass{article}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{ttquot}
\usepackage{pl-syntax}
\newcommand{\step}[0]{\ensuremath{\rightarrow}}
\newcommand{\bstep}[0]{\ensuremath{\Downarrow}}
\newcommand{\pstep}[0]{\ensuremath{\rightarrow_{\mathcal{S}}}}
\newcommand{\skips}[0]{~\textsf{skip}~}
\newcommand{\outputs}[0]{~\textsf{output}~}
\newcommand{\spawns}[0]{~\textsf{spawn}~}
\newcommand{\bop}{~\textsf{bop}~}
\newcommand{\uop}{~\textsf{uop}~}
\makeatletter
\newcommand{\conf}[1]{\langle #1\@confx}
\newcommand\@confx{\@ifnextchar\stopconf{\@confend}{\@confi}}
\newcommand\@confend[1]{\rangle}
\newcommand\@confi[1]{,#1 \@confx}
\makeatother

\begin{document}

\title{Sequential Semantics for Pipeline DSL}
\author{Drew Zagieboylo}
\maketitle

\section{MetaVariables}
\begin{align*}
  \begin{array}{lc}
    \mbox{Integers} & n \\
    \mbox{Variables} & v,f\\
    \mbox{Expressions} & e\\
    \mbox{Statements} & c\\
    \mbox{Functions} & \mathcal{F}\\
    \mbox{Objects} & \mathcal{O}\\
  \end{array}
\end{align*}

Program: List of Modules and Initial Conditions
Module: List of Stages, List of Locks, List of Formal Parameters (used to set initial conditions)
Lock: A special lock object with a few methods (acquire(), release(), reserve())
Stage: A set of receive statements, combinations assignments and guarded send statements
Input: Valid Bit, 
Commands: Limited IMP (no loops) + Barrier Statements
Barrier: Lock Name
Message: Module, Message Contents
Message Contents: Function Name, List of Arguments

\begin{figure}[h]
\begin{syntax}
  \abstractCategory[Variables]{v, x, z}
  \abstractCategory[Integers]{n, m}
  \abstractCategory[Locks]{L}
  \abstractCategory[Channels]{C}
  
  \category[Programs]{P}
  \alternative{ \{ List(M), List(v \mapsto n) \}}

  \category[Modules]{M}
  \alternative{ \{List(S), List(L), List(v)\}}

  \category[Stages]{S}
  \alternative{ "com" }

  \category[Expressions]{e}
  \alternative{ e " binop " e }
  \alternativeLine{ " unop " e }
  \alternativeLine{ e " ? " e " : " e }
  \alternativeLine{ v }
  \alternative{ n }
  \alternative{ b }
  \category[Commands]{"com"}
  \alternative{ "skip" }
  \alternative{ "com " ; " com" }
  \alternative{ v = e }
  \alternativeLine{ v = "recv " C}
  \alternative{ "if ("e") send(" e, C")"}
  \alternativeLine{ L".acquire()"}
  \alternative{ L".release()"}
  \alternative{ L".reserve()"}
\end{syntax}
\end{figure}
\section{Notes}

This language consists of a DAG of pipeline stages.
Each stage can be _occupied_ or _unoccupied_ and _active_ or _inactive_.
Occupied stages contain valid pipeline data from a prior
pipeline stage.
Active stages have received all of their inputs (from both
pipeline stages and other modules).
Every cycle, each _active_ stage executes its commands
and sends data to each of its ready successors (for that execution path).
Once a stage has sent data to all of its successors (for that execution path),
then it becomes unoccupied and invalid.
The semantics allow for "short-circuiting" such that a stage which is
becoming unoccupied can still receive data and remain occupied in the next cycle.

Additionally, this language has a notion of locks or barriers,
which provide further requirements before a stage can become active.
For instance, some stage may execute a command that acquires a read-lock
on a memory and then also execute a command to read that memory. Or it may
simply acquire the lock without reading the memory. They are separate commands.
\section{Operational Semantics}
Expression Semantics
\begin{mathpar}
  \inferrule*[Left={Ternary}]{\conf{\sigma}{e_b}\stopconf \bstep c \\ \conf{\sigma}{e_t}\stopconf \bstep n_t \\
  \conf{\sigma}{e_f}\stopconf \bstep n_f \\ n = c \neq 0 " ? " n_t " : " n_f}
             {\conf{\sigma}{e_b " ? " e_t " : " e_f}\stopconf \bstep n}\\
\end{mathpar}
Command Execution
\begin{mathpar}
  \inferrule*[Left={Recv-Block}]{ C.isEmpty()}
             {\conf{\sigma}{v = "recv " C}\stopconf \step \conf{\sigma}{v = "recv " C}\stopconf}\\
  \inferrule*[Left={Recv}]{!C.isEmpty() \\ \sigma' = \sigma[v \mapsto C.pop()]}
             {\conf{\sigma}{v = "recv " C}\stopconf \step \conf{\sigma'}{\skips}\stopconf}\\
  \inferrule*[Left={Send-Values}]{ \conf{\sigma}{e_g}\stopconf \bstep n_g \\ \conf{\sigma}{e}\stopconf \bstep n_v}
             {\conf{\sigma}{"if ("e_g") send(" e_v, C")"}\stopconf \step \conf{\sigma}{"if ("n_g") send(" n_v, C")"}\stopconf}\\
  \inferrule*[Left={Send-Guard-True}]{  n_g \neq 0 }
             {\conf{\sigma}{"if ("n_g") send(" n_v, C")"}\stopconf \step \conf{\sigma}{"send(" n_v, C")"}\stopconf}\\
  \inferrule*[Left={Send-Guard-False}]{  n_g = 0}
             {\conf{\sigma}{"if ("n_g") send(" n_v, C")"}\stopconf \step \conf{\sigma}{\skips}\stopconf}\\
  \inferrule*[Left={Send-Block}]{ C.isFull() }
             {\conf{\sigma}{"send(" n_v, C")"}\stopconf \step \conf{\sigma}{"send(" n_v, C")"}\stopconf}\\             
\end{mathpar}
Statement Semantics
Pipeline Semantics
\end{document}

# === comment
// === clock cycle boundary
=  === blocking write (a.k.a combinational logic, w/in a clock cycle)
<- === non-blocking write (a.k.a register or memory update, is visible next clock cycle)

#This block is the dest of definitions for instantiating the cpu
def cpu {
    #some pseudo syntax here for defining the units in our datapath
    imem = new cache<insn>();
    rf = new regfile();
    dmem = new cache<data>();
    alu = new arith_unit();
    bpred = new branch_pred();
}

#This implements a CISC ISA where instructions are of the form <op> <arg1> <arg2>
#Where args can be register indices or memory locations (depending on a few bits in arg1 and arg2)
#This implementation makes it clear how memory requests are ordered when it can
#multiple memory arguments.

cpu(pc) {

  insn <- imem.send(pc);
  //
  op = opcode(insn); #selects some bits from the instruction
  rs1 = rs1(insn);
  rs2 = rs2(insn);
  dest = rs2;
  if (op == BR) {
     arg1 <- rf.read1(rs1);
     arg2 <- rf.read2(rs2);
     //
     take_br = br_unit(insn, arg1, arg2) # checks the kind of comparison and executes it     
     if (take_br) {
     	return cpu(pc + imm(insn));
     } else {
        return cpu(pc + 4);
     }
  } else {
     spawn cpu(pc + 4);
     (arg1, arg2) <- match (rs1, rs2) {
       case REGISTER, REGISTER: {
         (rf.read1(rs1), rf.read2(rs2));
       }
       case REGISTER, MEMORY: {
         (rf.read1(rs1), dmem.read(rs2)); 
       }
       case MEMORY, REGISTER: {
         (dmem.read(rs1), rf.read1(rs2));
       }
       case MEMORY, MEMORY: {
          tmp = dmem.read(rs1);
	  //
	  (tmp, dmem.read(rs2));
       }
     }
     //
     res <- alu(arg1, arg2, op);
     //
     match (dest) {
       case REGISTER: {
         rf.write(dest, res);
       }
       case MEMORY: {
         dmem.write(dest, res);
       }
     }
  }
}

#actually instantiate and inintialize the cpu
main {
  cpu = new cpu();
  cpu.send(0);
}

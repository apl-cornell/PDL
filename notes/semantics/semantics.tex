\documentclass{article}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{ttquot}

\begin{document}

\newcommand{\states}[0]{\ensuremath{\mathcal{S}}}

\title{SpecLang Semantics}
\author{Drew Zagieboylo}
\maketitle

\section{MetaVariables}
\begin{align*}
  \begin{array}{lc}
    \mbox{Integers} & n \\
    \mbox{States} & s, l \\
    \mbox{Nonspeculative States} & l\\
    \mbox{State Set} & \states\\
    \mbox{Variables} & v\\
    \mbox{Expressions} & e\\
    \mbox{Statements} & c\\
  \end{array}
\end{align*}

\section{Lattice}

\section{Typing Rules}
%%\Gamma contains typing declarations
%%\Delta contains possible flow sensitive types
Expression Typing
\begin{mathpar}
  \inferrule*[Left={Var}] { \Gamma(v) = s } { \Gamma, \Delta \vdash v : (\{s\}, \{s\}) }\\
  \inferrule*[Left={SpecVar}] { \Gamma(v) = \states_1 \\ \Delta(v) = \states_2 } { \Gamma, \Delta \vdash v : (\states_1, \states_2) } \\
  \inferrule*[Left={Speculate}] { \Gamma, \Delta \vdash e : (\{s\}, \{s\}) \\ \Delta(v_1) = \states' \\ \forall s_i \in \states'. s_i \sqsubseteq  s \\ \states = \states' " map " "next"}
             { \Gamma, \Delta \vdash "speculate"(v_1, e) : \states} \\

\end{mathpar}
Statement Typing
\begin{mathpar}
  \inferrule*[Left={declaration-spec}] { v \not\in "dom("\Gamma")" \\ \mathcal{S} = \{s_1...s_n\}}
             { \Gamma, \Delta, pc \vdash "Spec "v \{s_1...s_n\} \dashv \Gamma[v \mapsto \mathcal{S}], \Delta[v \mapsto \mathcal{S}]}\\
  \inferrule*[Left={declaration-var}] { v \not\in "dom("\Gamma")" }
             { \Gamma, \Delta, pc \vdash v \{l\} \dashv \Gamma[v \mapsto \{l\}], \Delta}\\
  \inferrule*[Left={if}] { \Gamma, \Delta, pc \vdash e : (\mathcal{S}, \{s\}) \\
             \Gamma, \Delta, pc \sqcup s \vdash c_i \dashv \Gamma, \Delta_i \\ i \in \{1, 2\} }
             { \Gamma, \Delta, pc \vdash "if(" e ") then " c_1 " else " c_2 \dashv \Gamma, \Delta_1 \cup \Delta_2}\\
  \inferrule*[Left={test}] { \Gamma, \Delta[v \mapsto \{s_1...s_n\}], pc \vdash c_1 \dashv \Gamma, \Delta_1 \\
    \Gamma, \Delta[v \mapsto  "not" \{s_1...s_n\}], pc \vdash c_2 \dashv \Gamma, \Delta_2 }
             { \Gamma, \Delta, pc \vdash "if"("test " v, \{s_1...s_n\}) " then " c_1 " else " c_2
               \dashv \Gamma, \Delta_1 \cup \Delta_2}\\
  \inferrule*[Left={assign}] { \Gamma, \Delta \vdash e : (\{s_1\}, \{s_1\})
               \\ \Gamma,\Delta \vdash v : (\{s_2\}, \{s_2\}) \\ pc \sqcup s_1 \sqsubseteq s_2}
             { \Gamma, \Delta, pc \vdash v = e \dashv \Gamma, \Delta}\\
  \inferrule*[Left={assign-spec}] { \Gamma, \Delta \vdash e : (\mathcal{S}, \{s_1...s_n\}) \\ pc \sqsubseteq \bot }
             { \Gamma, \Delta, pc \vdash v = e \dashv \Gamma, \Delta[v \mapsto \{s_1...s_n\}]}\\
  \inferrule*[Left={verify}] { \Gamma, \Delta \vdash e : (\mathcal{S}, \{s\}) \\ pc \sqsubseteq \bot}
             { \Gamma, \Delta, pc \vdash v."verify"(e) \dashv \Gamma, \Delta[v \mapsto \{s, \top\}]}
\end{mathpar}
Thread Typing
\begin{mathpar}
  \inferrule*[Left={EndCycle}] { \forall v \in "dom("\Delta")". \Delta(v) = \Gamma(v)}
             { \Gamma, \Delta \vdash \langle skip, skip \rangle }
\end{mathpar}
\section{Dynamic Semantics}
Expression Semantics
\begin{mathpar}
  \inferrule*[Left={speculate}] { \langle \Delta, \sigma, e \rangle \Downarrow (l', n) \\ s = s'."next"}
             { \langle \Delta, \sigma, "speculate"(v_1, e) \rangle \Downarrow (l, n)} \\
             \inferrule*[Left={assign-com}] { \Delta, pc \vdash e : s }
                        { \Delta, pc \vdash v = e \dashv \Delta[v \mapsto pc \sqcup s]} \\
\end{mathpar}
Statement Semantics
\begin{mathpar}
  \inferrule*[Left={test-true}]{ \Delta(v) \in \{s_1...s_n\}}
             { \langle \Delta, \sigma, "if"("test " v, \{s_1...s_n\}) " then " c_1 " else " c_2 \rangle \rightarrow
               \langle \Delta, \sigma, c_1 \rangle} \\
  \inferrule*[Left={test-false}]{ \Delta(v) \not\in \{s_1...s_n\}}
             { \langle \Delta, \sigma, "if"("test "v, \{s_1...s_n\}) " then " c_1 " else " c_2 \rangle \rightarrow
               \langle \Delta, \sigma, c_2 \rangle} \\             
  \inferrule*[Left={assign-seq}]{ \langle \Delta, \sigma, e \rangle \Downarrow (l, n) }
             { \langle \Delta, \sigma, v := e \rangle \rightarrow \langle \Delta[\bar{v} \mapsto s],
               \sigma[\bar{v} \mapsto n], "skip" \rangle} \\
  \inferrule*[Left={assign-comb}]{ \langle \Delta, \sigma, e \rangle \Downarrow (l, n) }
             { \langle \Delta, \sigma, v = e \rangle \rightarrow \langle \Delta[v \mapsto s],
               \sigma[v \mapsto n], "skip" \rangle}               
\end{mathpar}
Resolve Block Semantics
\begin{mathpar}
  \inferrule*[Left={verify-success}]{ \langle \Delta, \sigma, e \rangle \Downarrow n \\
    \sigma(v) = n \\ \langle \Delta, e \rangle \Downarrow s }
  { \langle \Delta, \sigma, v."verify"(e) \rangle \rightarrow \langle \Delta[v \mapsto s], \sigma, "skip" \rangle}\\
  \inferrule*[Left={verify-fail}]{ \langle \Delta, \sigma, e \rangle \Downarrow n \\ \sigma(v) \neq n }
  { \langle \Delta, \sigma, v."verify"(e) \rangle \rightarrow \langle \Delta[v \mapsto \top], \sigma, "skip" \rangle}         
\end{mathpar}
Thread Semantics
\begin{mathpar}
  \inferrule*[Left={resolve-step}] { \langle \Delta, \sigma, c_r \rangle
    \rightarrow \langle \Delta^\prime, \sigma^\prime, c_r^\prime \rangle }
             { \langle \Delta, \sigma, c_r, c_s, t \rangle
               \rightarrow \langle \Delta^\prime, \sigma^\prime, c_r^\prime, c_s, t \rangle } \\
  \inferrule*[Left={combinational-step}] { \langle \Delta, \sigma, c_s \rangle
    \rightarrow \langle \Delta^\prime, \sigma^\prime, c_s^\prime \rangle }
             { \langle \Delta, \sigma, "skip", c_s, t \rangle
               \rightarrow \langle \Delta^\prime, \sigma^\prime, "skip", c_s^\prime, t \rangle } \\
  \inferrule*[Left={tick}] { \Delta' = \Delta[x_i \mapsto \Delta(\bar{x_i})][\bar{x_j} \mapsto \bar{x_j}] \\
               \sigma' = \sigma[x_i \mapsto \sigma(\bar{x_i})][\bar{x_j} \mapsto \bar{x_j}] }
             { \langle \Delta, \sigma, "skip", "skip", t \rangle
               \rightarrow_{\mathcal{R},\mathcal{S}} \langle \Delta^\prime, \sigma^\prime, \mathcal{R}, \mathcal{S} , t+1 \rangle}
\end{mathpar}
\end{document}

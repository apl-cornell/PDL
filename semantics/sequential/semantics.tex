\documentclass{article}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{ttquot}
\usepackage{pl-syntax}

\providecommand{\absint}[1]{\left \lfloor #1 \right \rfloor }
\newcommand{\step}[0]{\ensuremath{\rightarrow}}
\newcommand{\bstep}[0]{\ensuremath{\Downarrow}}
\newcommand{\pstep}[0]{\ensuremath{\rightarrow_{\mathcal{S}}}}
\newcommand{\skips}[0]{~\textsf{skip}~}
\newcommand{\outputs}[0]{~\textsf{output}~}
\newcommand{\spawns}[0]{~\textsf{spawn}~}
\newcommand{\locks}[0]{~\textsf{wait-for-lock}~}
\newcommand{\bypass}[0]{~\textsf{bypass}~}
\newcommand{\bop}{~\textsf{bop}~}
\newcommand{\uop}{~\textsf{uop}~}
\newcommand{\tdash}{\ensuremath{---}}
\makeatletter
\newcommand{\conf}[1]{\langle #1\@confx}
\newcommand\@confx{\@ifnextchar\stopconf{\@confend}{\@confi}}
\newcommand\@confend[1]{\rangle}
\newcommand\@confi[1]{,#1 \@confx}
\makeatother

\begin{document}

\title{Sequential Semantics for Pipeline DSL}
\author{Drew Zagieboylo}
\maketitle

\section{MetaVariables}
\begin{align*}
  \begin{array}{lc}
    \mbox{Integers} & n \\
    \mbox{Variables} & v,f\\
    \mbox{Expressions} & e\\
    \mbox{Statements} & c\\
    \mbox{Functions} & \mathcal{F}\\
    \mbox{Objects} & \mathcal{O}\\
  \end{array}
\end{align*}

\section{Type System}

The type system is used to enforce a number of constraints
that will ensure compilation of the program to a concurrent
system maintains correctness. This involves typechecking
a few different sets of rules:

\begin{itemize}
\item Base Types - Normal types for circuits like sized integers and booleans.
  We have a very limited notion of base types, like a subset of FIRRTL. This is mostly
  uninteresting.
\item Operation Timing - We have both synchronous (combinational) and asynchronous
  assignment. The latter is used to access arrays and external modules and the results
  of such operations take time to become available. We ensure that all variable
  accesses occur once their data has been made available (via logical the time-step operation '---').
  This is also relatively uninteresting.
\item Lock Acquisition - A key mechanism for ensuring correctness is ensuring
  that stateful operations (like writing to memories) happen in order. We ensure
  this order by forcing memory-accessing operations to happen only after the associated
  lock has been acquired. A secondary requirement of this check is that locks are
  acquired in-order; we enforce this by ensuring that there is exactly one point
  in the pipeline at which locks are acquired. This requirement can be relaxed with
  non-blocking acquisition (which we call reservation) that can happen in-order without
  forcing early pipeline stalls waiting for a lock that won't be needed until later.
\item Speculation - Speculation introduces some complexity and we must also
  prevent speculative code from executing any irreversible operations (such as
  modifying memory). However, speculative code *can* acquire and free locks,
  in certain cases. This checker ensures that all of those happen appropriately.
\end{itemize}

\begin{figure}[h]
  \begin{syntax}
    \abstractCategory[Variables]{v, x, z}
    \abstractCategory[Command]{c}
    \abstractCategory[Memory]{m}
    \abstractCategory[Pipeline Module]{\mathcal{P}}
    \category[LockState]{s}
    \alternative{"free"}
    \alternative{"reserved"}
    \alternative{"acquired"}
    \alternative{"released"}
    \category[LockReservationMap]{\mathcal{L}}
    \alternative{ m_1 \mapsto s_; m_2 \mapsto s_2;...;m_n \mapsto s_n }
    \category[LockMap]{L}
    \alternative{ m_1 \mapsto s_1; m_2 \mapsto s_2;...;m_n \mapsto s_n }
  \end{syntax}
\end{figure}

\subsection{Lock Reservation Regions}

\begin{mathpar}

  \mathcal{L}^1 " merge " \mathcal{L}^2 = \{ \forall m. m \mapsto s | s =
  \begin{cases}
    \mathcal{L}^1(m) & \mathcal{L}^1(m) = \mathcal{L}^2(m)\\
    "released" & \mathcal{L}^1(m) = "free" || \mathcal{L}^2(m) = "free"\\
    UNDEFINED &
  \end{cases}\}\\
  
  \boxed{ \mathcal{L} \vdash c \dashv \mathcal{L}'}\\

  \inferrule*[Left=StartRes]{ \mathcal{L}(m) = "free" \\ \mathcal{L}' = \mathcal{L}[m \mapsto "acquired"] }
             { \mathcal{L} \vdash "start"(m) \dashv \mathcal{L}' }\\
  \inferrule*[Left=EndRes]{ \mathcal{L}(m) = "acquired" \\ \mathcal{L}' = \mathcal{L}[m \mapsto "released"] }
             { \mathcal{L} \vdash "end"(m) \dashv \mathcal{L}' }\\
  \inferrule*[Left=ResOp]{ "loc" = m[x] || m \\ \mathcal{L}(m) = "acquired" }
             { \mathcal{L} \vdash reserve("loc") \dashv \mathcal{L} }\\
  \inferrule*[Left=If] { \forall i \in \{t, f\}. \mathcal{L} \vdash c_i \dashv \mathcal{L}^i \\
    \mathcal{L}' = \mathcal{L}^t " merge " \mathcal{L}^f \\
    \forall m. \mathcal{L}^t(m) = "released" \implies \mathcal{L}(m) = "acquired" || \mathcal{L}^f(m) = "free" \\
    \forall m. \mathcal{L}^f(m) = "released" \implies \mathcal{L}(m) = "acquired" || \mathcal{L}^t(m) = "free"}
             { \mathcal{L} \vdash "if " (c) " then " c_t " else " c_f \dashv \mathcal{L}'}

  \inferrule*[Left=AllReleased] { \forall m. \mathcal{L}(m) = "free" \\ \forall m. \mathcal{L}'(m) \in \{"free", "released"\}}
             { \mathcal{L} \vdash \mathcal{P} \dashv \mathcal{L}'}
\end{mathpar}

Lock reservation ensures that address-specific locks can be acquired over multiple
cycles while maintaining the correct reservation order.
These regions represent mutual exclusion sections and
prevent multiple threads from executing those regions of the pipeline in parallel.
Typically "start" and "end" should be placed in the same cycle to prevent runtime overhead.
Since "if" statements imply potential out-of-order execution the lock region for a given
memory can only start in at most one of the branches. However, lock regions can start outside
of "if" statements and be ended in each branch separately. The last rule ensures that all
modules typecheck assuming that all lock regions are currently free and at the end
of execution it must have released any lock regions that it acquired.

\subsection{Lock Acquisition}

All lock reservation must occur in one of the aforementioned reservation regions.
These rules ensure that all lock operations occur on locks that are in appropriate
states but do not need to check the lock reservation region status.


\begin{mathpar}
  \boxed{L \vdash c \dashv L'}\\
  \inferrule*[Left=MemRead]{ \mathcal{B} \implies L(m[x]) = "acquired"}
             { \mathcal{B}, L \vdash m[x] \leftarrow v \dashv \mathcal{B}, L }\\
  \inferrule*[Left=MemWrite]{ \mathcal{B} \implies L(m[x]) = "acquired"}
             { \mathcal{B}, L \vdash v \leftarrow m[x] \dashv \mathcal{B}, L }\\
  \inferrule*[Left=Reserve]{ \mathcal{B} \implies L(m[x]) = "free"}
             {\mathcal{B}, L \vdash "reserve"(m[x]) \dashv \mathcal{B}, L[m[x] \mapsto "reserved"]  }\\
  \inferrule*[Left=Acquire]{ \mathcal{B} \implies L(m[x]) = "reserved"}
             {\mathcal{B}, L \vdash "acquire"(m[x]) \dashv \mathcal{B}, L[m[x] \mapsto "acquired"] }\\
  \inferrule*[Left=Free]{ \mathcal{B} \implies L(m[x]) = "acquired" }
             {\mathcal{B}, L \vdash "free"(m[x]) \dashv \mathcal{B}, L[m[x] \mapsto "released"]}\\
  \inferrule*[Left=If]{
    \mathcal{B}_t = \mathcal{B} \wedge \absint{e} \\
    \mathcal{B}_f = \mathcal{B} \wedge "not"(\absint{e}) \\
    \mathcal{B}_t , L \vdash c_t \dashv \mathcal{B}_t, L_t \\
    \mathcal{B}_f, L \vdash c_f \dashv \mathcal{B}_f, L_f \\
    L' = \absint{e} " ? " L_t : ("not"(\absint{e}) " ? " L_f " : " L_{\top})}
             {\mathcal{B}, L \vdash "if " e " then " c_t " else " c_v \dashv \mathcal{B},L'}\\
\end{mathpar}

Locks must have been "acquired" to access the associated memory. Once a lock
is "free"ed, it cannot be acquired again since it is in the "released" state.
Lock acquisition happens in two steps: first the lock is "reserved" which enqueues
a request for the lock; second the lock is "acquired" by blocking until the lock status
says that the reservation is now owned by the current thread.

The $\mathcal{B}$ predicate tracks an abstraction of the currently valid branch conditions.
$\absint{e}$ is an abstract interpretation of the expression $e$ and is used to restrict or
prove the current state of a given lock. "if" statements create a new Lockstate map
that is represented as a ternary expression. The lookup operation into such a map
requires some predicate (provided by $\mathcal{B}$ in the other commands); if that
predicate proves part of the implication, then the lockstate for the given memory location
is looked up in that lock map.

_N.B._ The ternary lock map is not a simple if-then-else because $\absint{e}$ is an approximation
and therefore, being unable to prove $\absint{e}$ _does not imply_ $"not"(\absint{e})$. Therefore,
if neither of those can be proven the state is looked up in the ``unknown lock map'', $L_{\top}$.
This map always returns "unknown", or $\top$ as the state of the given lock, which will prevent
any of the lock related commands from typechecking.


\begin{mathpar}
  \boxed{ L \vdash \mathcal{P} \dashv L' }\\
  \inferrule*[Left={Deadlock-Free}]
             {\forall \{m,x\} "true" \implies L(m[x]) = "free" \\
             \forall \{m,x\}. L'(m[x]) \in \{"free", "released"\}}
             {"true", L \vdash \mathcal{P} \dashv "true", L'}
\end{mathpar}
Lastly, to avoid deadlock, like lock acquisition regions,
pipeline modules must type check with the assumption that no locks have been acquired,
and after execution all locks must either be "free" or "released"

\end{document}
